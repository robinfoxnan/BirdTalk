# 集群中消息流转策略讨论

目前群聊的存储策略是1写多读方案；每个群组一个队列，按时间顺序排列，不区分用户；

私聊的存储是写扩散的，每个都有自己的消息队列，按时间顺序 保存所有的消息，不区分会话；

# 1、单机模式

## 1.1 私聊消息

## 1.2 群聊消息

# 2、集群模式

## 2.1 私聊消息

假如有服务器A和服务器B，小明在服务器A，小美在服务器B；

开始时候小美不在线，消息都写入了小美的消息队列；当某一时刻，小美在服务器B登录，那么：

1）先告知集群当前此用户的此会话在服务器B；

2）执行一次同步历史数据之后，准备接收来自其他服务器用户的数据，当然也包括服务器A;

这里存在一个问题：

服务器A上的小明发现小美上线前，将数据写到了小美的消息队列，但是其实此刻，小美已经上线并且同步完数据了；那么这条消息就会被服务器遗漏，小美客户端也无从得知该条消息；

这个问题的产生主要是路由状态的扩散需要时间，异步的同步历史数据会造成潜在的数据丢失。

但是，与群聊不同，私聊是有回执的；当小明发现小美一直都没有回复接收回执，则会一直查询回执，服务器A会重发消息，此时如果发现了消息路由在服务器B，可以保证消息重发而不丢失；

但是有个缺点也很明显：有可能之前丢失的消息会在客户端出现乱序！！！



## 2.2 群聊消息



假如有服务器A和服务器B，一个群组G100；小明在服务器A，小美在服务器B；

当小美在服务器登录时间不确定的时候如何保证群聊消息不丢失？

可能会丢失的原因在于：

1）分布式环境下，消息的编号不是连续的流水号，无法通过编号来判断是否发生了丢失；

2）登录后如果只与服务器B同步一次数据，同步数据与其他服务器发现路由有时间差，时间差内的消息会丢失；



那么处理方式也很明显：

**1）传统轮询模式：**每次查询都告知服务器最后一条的ID，然后从数据库表中查询后续的消息，对于scylladb来说肯定是比传统的数据库强，但是效率仍然很低；

**2）暴力的集群同步：**不管服务器B是否有G100群组的用户在线，一直连续不断的转发消息，那么可以服务器B上存在的消息在时间上是连续的，那么登录后，同步一次数据就可以保证与后续转发的数据无缝衔接；

## 2.3 优化解决方法

那么针对2种方案时候有优化的方案呢？矫正后的算法对私聊和群聊都有效，原理是执行2次同步以便在时间上覆盖所有范围：

**3) 时间戳矫正法：**

小美在服务器B登录，就绪后将状态广播到集群，之后开始同步群G100的历史数据；假设最后一条数据编号LAST_ID=1000200；(真实环境使用雪花算法)

**可能一**：服务器A早就发现服务器B有群组G100其他用户，一直在转发数据，那么小美不会丢失数据，因为是流程是先设置状态后同步数据，服务器B可以保证消息没有丢失；对于同步前收到的数据，客户端先写到本地库，同步数据完成后再显示就不会乱序；

