

# 1. 整体结构



# 2. 用户基础信息

## 2.1 基础存储

考虑到用户基础信息会扩展，这里并不适合使用列固定的数据库，所以这里勉为其难的使用mongoDB。

使用的结构与传输协议中基本保持一致；

```protobuf
message UserInfo {
  int64 userId = 1;        // 注册时候全局分配的
  string userName = 2;     // 用户名
  string nickName = 3;     // 昵称
  string email = 4;        // 邮箱
  string phone = 5;        // 手机号
  string gender = 6;       // 性别
  int32 age = 7;           // 年龄
  string region = 8;       // 地区
  string icon = 9;         // 头像
  map<string, string> params = 10;  // 其他参数，使用map存储比如，title, pwd, sid, icon
}
```



1）用户名是精确查找，手机号，邮箱都是，关键字直接匹配3个字段其中一个，比关系数据库方便太多了！

2）用户名不允许一样，但是出于性能考虑没有使用唯一索引；这里更新时候需要先检查一下是否有一致的

3）用户号码使用唯一索引，是个int64；

4）用户名，邮箱与手机加索引，但是非唯一；

函数部分包括3类：

创建：

```go
 MongoClient.CreateNewUser(&userInfo)
```

整体更改：

```go
 MongoClient.UpdateUserInfo(&userInfo)
```

部分更改：

```go
MongoClient.UpdateUserInfoPart(10001, setData, nil)
```

搜索：可以按照userid快速查找，也可以根据用户名、手机号、邮箱精确搜索；

```
MongoClient.FindUserById(10001)

MongoClient.FindUserByKeyword("john_doe")
```

用名字查找的函数主要用来判重：

```
MongoClient.FindUserByName("robin")
```



## 2.2 redis 缓存

键值说明：

1）键值使用"tu" + userid，每个用户都是hash表；

2）“tu_state”广播用于通知用户上线；



使用逻辑：

1）在用户创建的时候，并不加载到redis；

2）如果用户登录时候才加载；所以redis中有的记录那么都是登录状态的；超时设置为10分钟，会话协程需要定时设置超时时间，如果该key超时了，说明用户下线了；用户上线需要使用广播来通知服务器集群中的所有用户；

3）更改之后，更改成功的话，从内存中直接替换redis中的信息；用户如果更改了信息也需要使用广播通知；

4）会话中，需要查找对方用户，如果redis中没有用户信息，则说明用户离线状态，则不需要转发；





## 2.3 服务内部内存缓存

因为每条转发都需要检查是否被屏蔽了，对方是否在线，那么为了加速，需要将用户信息加载到内存；为了防止redis广播丢失，定时需要同步一次；



# 3. 群组信息

群组的基本信息也使用mongoDB来存储；

## 3.1 基础存储

```protobuf
// 群组信息
message GroupInfo {
  int64 groupId = 1;            // 注册时全局分配的群组ID
  repeated string tags = 2;     // 群组标签
  string groupName = 3;         // 群组名称
  string groupType = 4;         // 群组类型，例如：群聊、广播频道等
  map<string, string> params = 5;  // 其他参数，例如：是否公开、验证方法、验证口令等
}
```

1) 组ID唯一，组名随便设置主要是给群成员看的，相当于一个简介；

2) tags是多个字符串的一个数组，用于模糊搜索的，对于公开群组和频道有意义；

3) 如果是私聊的群组，不能关键字搜索;

函数：

1）创建，公开群设置"params.v"="pub"; 

私有群设置"params.v"="pri"同时  "params.code"="asafaf"，这个代码是系统生成的随机码，分享时候发给客户；

```
err = MongoClient.CreateNewGroup(&group)
```

2）公开群搜索，函数内过滤群公开属性：其中params.v = "pub"

```
grps, err := MongoClient.FindGroupByKeyword("测试群"， "")

grps, err := MongoClient.FindGroupById(10002)
```

3）私群不能通过tags搜索到，只能通过id和一个"params.code"匹配来找到并加入，申请中需要有个code

```
grps, err := MongoClient.FindGroupByKeyword("测试群", "")
```

4) 设置信息

```

```





## 3.2 redis缓存



## 3.3 服务内部缓存





# 4. 用户的好友信息

好友关系使用scyllaDB存储，每个组的信息可以通过分簇来存储在一起；

这里支持2种模式，交友的那种双向好友，以及社区模式的关注与粉丝；

存储上使用2个表来表示，following和fans分别表示用户的关注列表和好友列表；

还有一个不常用的表，拉黑列表，这个列表表示不接受对方的消息，也不要推荐对方的内容；

## 4.1 社区模式

A-->B，A关注B，这不需要验证，仅仅以系统身份发送通知；（取关，不发送通知：）

那么在A的following表中添加B；从数据库加载后，在redis中添加计数；

同时在B的funs的表中添加A；从数据库加载后，在redis中添加计数；

如果B--> A，B也关注了A，

那么在A和B的2个列表中都会出现对方，那么就是双向好友；



在这样的模式下，粉丝列表可能会非常多，百万或者千万都有可能，这里查询就不能直接返回所有成员；



每个用户还需要个单独的屏蔽列表，免打扰模式；

## 4.2 交友模式

在需要验证的交友模式下，也需要每个用户分别使用一个表来存储对方，因为需要为对方设置备注信息；

客户端看到的好友列表，不过是服务端直接对2个列表求一个交集，一般这样的好友列表不会太长，顶多2000个；



# 5. 群组的成员信息

群组的成员使用scyllaDB存储，每个组的信息可以通过分簇来存储在一起；

