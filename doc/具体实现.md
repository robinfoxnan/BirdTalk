# 一、会话与用户管理

# 二、消息处理

## 2.1MsgTHello

### 2.1.1 客户端

客户端应该设置如下几个参数：

Msg必选：

- 协议号 = 1.0  整数；
- 时间戳：毫秒时间戳；
- keyPrint指纹：这里如果是0，表示不加密；
- msgType: hello 类型；



hello 消息必选：

- ClientId: 终端的唯一编码，字符串；
- Platform:所在的平台，字符串；
- Version: 客户端版本号，字符串；
- Stage:客户端应该写"clienthello"，字符串；
- keyPrint指纹：如果是0，代表目前没有协商过秘钥；**如果不是0，代表申请使用协商过秘钥；这里的指纹作为会话的凭证Token;**

hello 可选的参数：
- Lang: 编程语言；

- CountryCode: 国家代码；

- CodeType: 协议编码："json"或者"protobuf"

- **Params:  使用键值"checkTokenData"，内容使用对tm时间戳的字符串加密，并计算base64;作为验证秘钥一致性的凭据；**

  

客户端得到的结果：

1. 当协议号错误，得到协议错误消息；客户端无法登录，应该重新更新整个客户端版本；

2. 如果keyprint无法找到，或者keyprint加密数据无法验证，则返回keyprint错误；客户端应当删除凭证；

3. 如果没有遇到错误，则的可以收到Hello应答；

   3.1）如果keyprint为0，Stage为"waitlogin"下一步可以协商秘钥，也可以直接登录；

   3.2)  如果keyprint不为0，指纹错误则需要删除秘钥；如果秘钥验证没有问题Stage为"needlogin"，则说明之前未登录，或者已经退出登录，需要重新验证身份；如果检查不用登录验证，则会收到Stage= "waitdata"，可以申请同步数据，发消息；




### 2.1.2 服务端

1. 需要验证协议号是否正确；如果协议版本号不对，则应该返回错误；

2. 如果hello中设置了keyprint，说明以前使用的秘钥，这里需要对秘钥的附加数据进行验证，同时在redis中查看用户状态，如果登录过则回复Stage= "waitdata"，如果未登录成功，则回复Stage= "needlogin"；

3. 重定向不在这里做，因为如果使用IP方式计算有问题：

   3.1）用户的不同终端在异地登录，集群中不再同一主机，同步数据容易丢失；

   3.2）用户的移动终端IP可能经常移动，那么每次都需要更换服务器；

4. 如果一起正常，返回hello 应答；

   4.1）指纹错误，无法找到，或者无法解密；

   4.2）**等待协商秘钥或者登录"waitlogin"，秘钥关联的会话状态未登录"needlogin"， 秘钥验证后不必登录 "waitdata"；**



## 2.2 MsgTKeyExchange

这一节动作是**可选**的；客户端实现这一部分的好处主要是不必频繁使用用户名密码登录，也不用使用邮箱或者手机号验证身份；

参考《DH秘钥交换.md》这里实现了部分秘钥交换；

1）不使用RSA公私钥；明文传递密钥对的公钥；（TODO：使用RSA）

2）交换秘钥后不作为加密使用，暂时用作免密码登录的机制；(TODO：加密传输)

握手分为4步：

### 2.2.1  客户端发送公钥

流程如下：

1. 计算公私钥对；并使用 SPKI 格式导出，并使用标准PEM格式封装公钥；

2. 发送公钥；stage=1; rsa为空；

3. 指定加密方式，AES-CTR,  ChaCha20, twofish128

   ```js
   `-----BEGIN PUBLIC KEY-----
   MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEPtUgsMSgDr2AtLkC78v4ftayTMb6
   Q9vj5Mk7GbKLbs/xutvM/EmxLsX78mPZdKwHqMU5uFzAT3wt7q5OZWjrJA==
   -----END PUBLIC KEY-----`
   ```

   Stage = 1;

### 2.2.2  服务器发送公钥、指纹、验证数据

1. 服务端生成秘钥对，并计算共享密钥；
2. 使用秘钥按照约定的加密算法执行加密：对tm转字符串，之后加密放到TempKey字段；
3. 如果是32字节的秘钥算法直接使用；如果是16字节的计算MD5;
4. 根据秘钥计算指纹；取秘钥的低64比特；

发送函数为：

```go
sendBackExchange2
```
正常情况下，应答为stage = 2; Status:   "ready";

错误情况下，应答为Error消息；

### 2.2.3  客户端发送指纹、验证数据

1. 计算共享密钥，并计算指纹；

2. 比对指纹，同时比对验证数据；如果2者都正确，则保存指纹和密钥，同时执行下一步；

3. 如果出现问题，则应该向用户汇报，因为程序本身有问题；

4. 没有问题，用户发送第三次握手，将tm数据加密，给服务器验证；

   Stage = 3;

   Status = "ready"

### 2.2.4  服务器应答

```
sendBackExchange4
```

1. 服务器验证数据，没有问题，在redis中保存共享密钥，指纹；

2. 保存指纹前应该检查是否存在同样的指纹，如果存在指纹碰撞则应该回复错误，重新协商一个新的秘钥；ErrTKeyConflict

   

正常情况下，应答为stage = 4;  Status:   "needlogin"，如果发送错误信息，则说明最后一步出问题了；



 **备注**：这里先运行一段时间，如果碰撞的概率变大之后，在集群模式下先对共享密钥取哈希，然后再去取低64比特作为指纹；



## 2.3 MsgTUserOp

所有的用户基本操作都不转发，好友操作只有在交友模式下需要转发；

所有请求都需要检查用户的权限，

1）除了注册和登录动作，都需要检查是否登录；

2）设置

### 2.3.1 请求注册

注册目前分为三类：

1. 匿名注册：提供用户名，口令，注册后返回一个用户号码；
2. 邮箱注册：提供一个邮箱，使用验证码登录；
3. 手机号注册：暂时不支持；

#### 2.3.1.1 客户端注册

一般的实现，应该在协商秘钥之后申请；

应该在user 信息中填写基础的部分，并在

Params中设置：

```
"regmode" ："anonymous"
"regmode" ："email"
```

匿名用户需要提供口令，如果是邮箱注册则需要重新发送验证码；

用户可能会收到如下几种回复：

**用户操作应答**：匿名注册一般直接完成，返回基本信息并直接登录成功；如果是需要验证码，会提示

**错误**：

1）邮件地址不合法；

2）匿名未设置口令；

3）服务器内部错误发生错误；

当用户成功时也会收到3种消息

| 类型          | result | status    |                      |
| ------------- | ------ | --------- | -------------------- |
| 邮件注册阶段1 | ok     | waitcode  | 需要提交验证         |
| 匿名注册      | ok     | needlogin | 需要重新尝试登录     |
| 匿名注册      | ok     | loginok   | 免登录，直接可以操作 |

备注：匿名用户无法取回密码，一旦丢失，则无法使用；



#### 2.3.1.2 服务端处理

检查注册类型，只要设置了合法的邮箱地址，就认为是邮箱注册；

1. 邮箱注册：保存临时信息，同时计算验证码，使用邮件发送验证码，等待用户提交验证；

2. 匿名注册：不需要验证码，直接生成流水号分配给用户，保存用户；加载用户信息成功则免登录；

3. 加载用户步骤：

   ```
   1) 从数据库加载
   2) 保存到redis
   3) 同步内存
   4) 将用户绑定到指纹
   5) 发送同步信息，登录
   ```



### 2.3.2 请求注销

### 2.3.3 禁用用户

### 2.3.4 恢复用户

### 2.3.5 请求登录

如果计算IP后，需要重定向，则返回需要重定向的消息；

如果在登录的地方，先验证时候合法，如果合法，则提示用户应该重定向；

重定向之后使用指纹登录很快；



### 2.3.6 提交验证码

验证码有2种可能：

1）注册阶段

2)  登录阶段

3）更改信息

### 2.3.7 设置用户信息

### 2.3.8 搜索用户

### 2.3.9 请求添加好友

### 2.3.10 好友确认

### 2.3.11 移除好友

### 2.3.12 拉黑

### 2.3.13 移除拉黑

### 2.3.14 设置朋友权限

### 2.3.15 设备对方备注







