# 一、会话与用户管理

## 1.1  三级用户数据管理

### 1.1.1 超时机制

首先，交友模式下，一般粉丝和关注，都不会太多，一般是双向好友；通常情况下2000算是比较多的了；客户端内的数据是逐步累积的，登录时候不需要同步好友数据，仅仅在点击查看时候更新对方的信息即可；平时存储ID，昵称以及头像即可；客户端也很容易得知自己的双向好友的个数；

在社区模式下，很多大V的粉丝经常有几十万，几百万，上千万；平常用户的关注也可能有上万之多；那么这样的情况下，即便是客户端有存储好友数据，也没有必要全部存储；比如SQLITE存储几万条数据还是可以接受的，但是存储几百万的粉丝数据并没有意义，这样的用户也不会去与每个粉丝互动。所以这样的情况下，不需要在客户端本地加载那么多的粉丝的具体数据，存储1000条左右就够了，如果查看的话，可以按需加载。

不过这样的情况下需要在redis中缓存用户的关注和粉丝个数；这个缓存信息永不过期，因为数据库中不存精确信息；（当然，也可以定期存储一下，防止redis崩溃，无法修复，也没有必要实时落库，毕竟如果量大就十分浪费资源）

在目前的版本定位，单机版支持10万级别的用户，主要是针对基于定位的交友聊天，同时支持少量的发帖功能；



**因此**，

1）redis策略：在用户登录时候检查加载，同时加载好友信息，数据条数需要做出限制，比如1000条数据好友数据，如果更多，则需要从数据库去加载；这里按照好友的ID去排序即可；

redis的超时机制：默认用户的信息TTL为7天，然后在session写的线程中，定期更新TTL;

- 会话的读协程更新内存的最后活动时间戳；

- 会话的写线程更新Redis的TTL;

- 社区模式下，（可以不用加载好友信息），登录时候同步粉丝与关注的个数；

- 交友模式下，需要加载好友信息；因为这部分信息在聊天转发时候做权限识别；

  

2）内存缓存：登录的用户才保存内存信息；每次操作都记录时间点，如果用户的所有session 都退出了，并且超时了一段时间，就是长久未登录，就删除掉；**这里需要一个后台垃圾清理协程；**

登录后并不需要加载好友列表到内存，使用了哪个好友的信息，仅仅是聊天触发 的时候保存聊天对象的权限就可以了；

转发聊天数据时候，先检查内存的权限控制，如果没有则需要从redis中查看粉丝列表以及对方给自己设置的权限；如果没有数据再去数据库中查找；、

**离线识别：**

- 单机模式：首先检查内存用户中session数量可以知道用户在线状态；如果没有内存换缓存的也是离线的；

- 集群模式：用户需要在redis中维持一个动态状态表，也设置超时时间，使用一个Hash表维护用户的所有的session;

  | key      | field | value           |
  | -------- | ----- | --------------- |
  | 前缀+uid | sid   | 服务器index数字 |

  写写成中定期更新，比如5分钟；设置超时TTL。



### 1.1.2 总结redis的更新TTL列表

用户涉及的键值如下：

| 键                 | 超时   | 前缀    | 备注                                                 |
| ------------------ | ------ | ------- | ---------------------------------------------------- |
| 用户基础信息表     | 7天    | bsui_   |                                                      |
| 用户好友权限表     | 7天    | bsufb_  |                                                      |
| 用户关注表         | 7天    | bsufo_  |                                                      |
| 用户粉丝表         | 7天    | bsufa_  |                                                      |
| 用户的指纹表       | 7天    | bsut_   |                                                      |
| 用户所属群组       | 7天    | bsuing_ |                                                      |
| 用户session 分布表 | 30分钟 | bsud_   | session结束时删除field，<br>这个定时器更新需要单独做 |
|                    |        |         |                                                      |

函数：

UpdateUserTTL(): 更前7天有效的TTL;

 SetUserSessionOnServer(): 负责更新会话标记的那个TTL；





群组涉及到表：

|     键                 | 超时   | 前缀    | 备注      |
| ---- | ---- | ---- | ---- |
| 组基础信息 | 7天 | bsgi_%d |      |
| 组所有成员表 | 7天 | bsgu_%d |      |
| 组成员在各个服务器上计数 | 长期 | bsgd_%d | hash |
| 组成员在各个服务器上的列表 | 长期 | "bsgdi_%d_%d" | set |
| 组内最新消息缓存 | 7天 | bsgmsg_%d | list |
|      |      |      |      |

- 长期有效的表，在群组不解散时候不能删除，因为删除了就无法得知用户分布了，也就无法消息路由了；
- 由守护线程来处理：遍历所有的组信息表，如果超过1小时都没有活动过就不去更新TTL，如果最新有消息在传递，就更新TTL



### 1.1.3 用户信息加载与超时

用户信息的加载，涉及如下流程：

**LoadUser函数**

```
1) 从数据库加载
2) 保存到redis
3) 同步到内存
4) 将用户绑定到指纹 （新注册用户、登录用户都需要做）


可选
5) 加载粉丝
6) 加载关注
7) 加载权限
8) 加载所在的群组列表
```

​	**关于用户的加载有4种情况：**

1）新注册的用户：不用加载好友等信息，一定都是空的，没有必要操作5 - 8；

2）老用户登录：如果内存用户数据未过期，则只需要绑定指纹；如果redis中有数据从redis加载; 否则从数据库加载；但是只有基础信息，权限，组信息加载到内存；好友信息根据聊天的需要加载，而且仅仅是一个过滤器；

3）其他用户搜索此用户，优先从redis查找，否则从数据库加载；查找后，仅仅加载到redis基本的信息，但是不造成内存加载数据；（离线用户可能很久都不再登录，也不会有其他人搜索）

4）其他用户向他发送消息：先检查是否是好友，查看自己的fans是否标记了，没有标记查redis中fans的nick如果为空字符串，则不是好友；如果redis没有设置，则应该从数据库查询并添加到redis和内存；再检查权限，权限也是从内存开始查，如果内存没有设置，则从redis中对方的权限表中查找，如果没有再从数据库中查找，找到后就设置到redis和内存，如果没有找到，返回朋友或者陌生人的默认值。



**加载好友的流程如下：**

1）按照分页1000来加载数据库中的好友和权限，如果返回的数据少于1000，则说明加载完毕，更新redis的好友条目数据；在当前的版本中，应该设置限制用户的好友个数，加入的组的个数；这里，开始阶段数据是准确的，但是如果redis崩溃过，那么数据量大的时候肯能会不准确；

todo: 定时保存到数据库，应该在redis中加个标记，定时检查；

2）如果多于1000条，说明后续还有，就应该尝试检查redis或者数据库中的好友计数；即便没有也不能使用数据库的统计，容易造成死机；1000万条好友数据就是10M * N字节，一条记录平均35字节，就是350MB，丢失数据应该由运维去手动处理；

3）备注：在用户注册时候，就应该在redis中添加好友和粉丝的记录；长期有效。



**好友计数的存储：**

使用2个大的hash分别存储所有用户的的粉丝和关注数量



| key          | field | value |
| ------------ | ----- | ----- |
| user_fans    | uid   | 数字  |
| user_follows | uid   | 数字  |

使用一个set来管理所有更新过计数的字段，定时清空 set，根据set记录 的key来落库。



## 1.2 会话与用户管理

### 1.2.1 会话启动（登录）时清单

OnUserLogin()函数

1） 加载用户；（绑定指纹，将会话绑定到用户）

2） 更新TTL；

3）广播通知上线，（通知所有的会话对象更改在线状态？）微信没有，其他的聊天工具有；

4）更改群组的相关成员状态；



### 1.2.2 会话结束（退出）时清单

OnUserLogout()函数：

1) 从用户信息中解绑会话；

2）更新一遍TTL;

3)  删除动态信息表中的field;



### 1.2.3 守护线程清理

1)  每次用户操作都更新User类的最后活动时间戳；

2）定时扫描所有的用户，一定时长未活动的用户（24小时）直接删除；



## 1.3 群组用户



# 二、消息处理

## 2.1MsgTHello

### 2.1.1 客户端

客户端应该设置如下几个参数：

Msg必选：

- 协议号 = 1.0  整数；
- 时间戳：毫秒时间戳；
- keyPrint指纹：这里如果是0，表示不加密；
- msgType: hello 类型；



hello 消息必选：

- ClientId: 终端的唯一编码，字符串；
- Platform:所在的平台，字符串；
- Version: 客户端版本号，字符串；
- Stage:客户端应该写"clienthello"，字符串；
- keyPrint指纹：如果是0，代表目前没有协商过秘钥；**如果不是0，代表申请使用协商过秘钥；这里的指纹作为会话的凭证Token;**

hello 可选的参数：
- Lang: 编程语言；

- CountryCode: 国家代码；

- CodeType: 协议编码："json"或者"protobuf"

- **Params:  使用键值"checkTokenData"，内容使用对tm时间戳的字符串加密，并计算base64;作为验证秘钥一致性的凭据；**

  

客户端得到的结果：

1. 当协议号错误，得到协议错误消息；客户端无法登录，应该重新更新整个客户端版本；

2. 如果keyprint无法找到，或者keyprint加密数据无法验证，则返回keyprint错误；客户端应当删除凭证；

3. 如果没有遇到错误，则的可以收到Hello应答；

   3.1）如果keyprint为0，Stage为"waitlogin"下一步可以协商秘钥，也可以直接登录；

   3.2)  如果keyprint不为0，指纹错误则需要删除秘钥；如果秘钥验证没有问题Stage为"needlogin"，则说明之前未登录，或者已经退出登录，需要重新验证身份；如果检查不用登录验证，则会收到Stage= "waitdata"，可以申请同步数据，发消息；
   
4. 如果使用keyPrint直接登录，那么如果验证数据无误后会直接发回登录回执，不再应答hello; 如果有秘钥，但是显示未登录，则回复"needlogin"




### 2.1.2 服务端

1. 需要验证协议号是否正确；如果协议版本号不对，则应该返回错误；

2. 如果hello中设置了keyprint，说明以前使用的秘钥，这里需要对秘钥的附加数据进行验证，同时在redis中查看用户状态，如果登录过则回复Stage= "waitdata"，如果未登录成功，则回复Stage= "needlogin"；

3. 重定向不在这里做，因为如果使用IP方式计算有问题：

   3.1）用户的不同终端在异地登录，集群中不再同一主机，同步数据容易丢失；

   3.2）用户的移动终端IP可能经常移动，那么每次都需要更换服务器；

4. 如果一起正常，返回hello 应答；

   4.1）指纹错误，无法找到，或者无法解密；

   4.2）**等待协商秘钥或者登录"waitlogin"，秘钥关联的会话状态未登录"needlogin"， 秘钥验证后不必登录 "waitdata"；**



## 2.2 MsgTKeyExchange

这一节动作是**可选**的；客户端实现这一部分的好处主要是不必频繁使用用户名密码登录，也不用使用邮箱或者手机号验证身份；

参考《DH秘钥交换.md》这里实现了部分秘钥交换；

1）不使用RSA公私钥；明文传递密钥对的公钥；（TODO：使用RSA）

2）交换秘钥后不作为加密使用，暂时用作免密码登录的机制；(TODO：加密传输)

握手分为4步：

### 2.2.1  客户端发送公钥

流程如下：

1. 计算公私钥对；并使用 SPKI 格式导出，并使用标准PEM格式封装公钥；

2. 发送公钥；stage=1; rsa为空；

3. 指定加密方式，AES-CTR,  ChaCha20, twofish128

   ```js
   `-----BEGIN PUBLIC KEY-----
   MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEPtUgsMSgDr2AtLkC78v4ftayTMb6
   Q9vj5Mk7GbKLbs/xutvM/EmxLsX78mPZdKwHqMU5uFzAT3wt7q5OZWjrJA==
   -----END PUBLIC KEY-----`
   ```

   Stage = 1;

### 2.2.2  服务器发送公钥、指纹、验证数据

1. 服务端生成秘钥对，并计算共享密钥；
2. 使用秘钥按照约定的加密算法执行加密：对tm转字符串，之后加密放到TempKey字段；
3. 如果是32字节的秘钥算法直接使用；如果是16字节的计算MD5;
4. 根据秘钥计算指纹；取秘钥的低64比特；

发送函数为：

```go
sendBackExchange2
```
正常情况下，应答为stage = 2; Status:   "ready";

错误情况下，应答为Error消息；

### 2.2.3  客户端发送指纹、验证数据

1. 计算共享密钥，并计算指纹；

2. 比对指纹，同时比对验证数据；如果2者都正确，则保存指纹和密钥，同时执行下一步；

3. 如果出现问题，则应该向用户汇报，因为程序本身有问题；

4. 没有问题，用户发送第三次握手，将tm数据加密，给服务器验证；

   Stage = 3;

   Status = "ready"

### 2.2.4  服务器应答

```
sendBackExchange4
```

1. 服务器验证数据，没有问题，在redis中保存共享密钥，指纹；

2. 保存指纹前应该检查是否存在同样的指纹，如果存在指纹碰撞则应该回复错误，重新协商一个新的秘钥；ErrTKeyConflict

   

- 正常情况下，应答为stage = 4;  Status:   "needlogin"，
- 如果发送错误信息，则说明最后一步出问题了；



 **备注**：这里先运行一段时间，如果碰撞的概率变大之后，在集群模式下先对共享密钥取哈希，然后再去取低64比特作为指纹；



## 2.3 MsgTUserOp

所有的用户基本操作都不转发，好友操作只有在交友模式下需要转发；

所有请求都需要检查用户的权限，

1）除了注册和登录动作，都需要检查是否登录；

2）搜索好友返回的是多个用户信息，里面都是搜索到的用户，也有可能是空的；请求好友信息返回的结果是2个用户信息，第1个请求者，第2个是应答者；其他的操作都是单个用户信息；

### 2.3.1 请求注册

注册目前分为三类：

1. 匿名注册：提供用户名，口令，注册后返回一个用户号码；
2. 邮箱注册：提供一个邮箱，使用验证码登录；
3. 手机号注册：暂时不支持；

#### 2.3.1.1 客户端注册

一般的实现，应该在协商秘钥之后申请；

应该在user 信息中填写基础的部分，并在

Params中设置：

```
"regmode" :"anonymous"
"regmode" :"email"
"regmode" : "phone"  // 暂时没有支持
```

匿名用户需要提供口令，如果是邮箱注册则需要重新发送验证码；

用户可能会收到如下几种回复：

**用户操作应答**：匿名注册一般直接完成，返回基本信息并直接登录成功；如果是需要验证码，会提示

**错误**：

1）邮件地址不合法；

2）匿名未设置口令；

3）服务器内部错误发生错误；

当用户成功时也会收到3种消息

| 类型          | result | status    |                      |
| ------------- | ------ | --------- | -------------------- |
| 邮件注册阶段1 | ok     | waitcode  | 需要提交验证         |
| 匿名注册      | ok     | needlogin | 需要重新尝试登录     |
| 匿名注册      | ok     | loginok   | 免登录，直接可以操作 |

备注：匿名用户无法取回密码，一旦丢失，则无法使用；



#### 2.3.1.2 服务端处理

检查注册类型，只要设置了合法的邮箱地址，就认为是邮箱注册；

1. 邮箱注册：保存临时信息，同时计算验证码，使用邮件发送验证码，等待用户提交验证；这里需要验证邮箱没有使用过；验证码的键值为"code"

2. 匿名注册：不需要验证码，直接生成流水号分配给用户，保存用户；加载用户信息成功则免登录；

3. 加载用户：参考第（一）章；



4. **todo:** 做登录的状态通知 

   比如用户所在的所有群，都需要更新在线通知；

   ```
   1) 通知他的好友上限通知；
   2）redis中同步所在的群，用户在线状态更新；
   3）用户的密码是否需要使用
   ```

5. 应答：

   这里使用SendBackUserOp() 函数应答，里面只有一个用户信息；

   

### 2.3.2 请求注销

客户端可以不用设置用户信息；会话中登录后有；



服务端对用户做标记，

```
"Params.status" = "deleted"
```

表示已经删除；

该用户无法再登录，也无法被除系统管理员外的其他人查询信息；

注销后，返回状态码："unregok"

并直接断开连接；



### 2.3.3 禁用用户

此功能对管理员开放，入口函数前，对会话的权限做检查，如果权限合适，可以执行此操作；

目前的认为是会话的userId 小于10000的是系统账户，可以操作，后期需要添加系统账户的相关功能；

这里直接对数据包中的用户做状态设置；系统用户发送数据包前需要做2个设置:

```
userInfo.User
userInfo.Params["reason"]  // 用户被禁用的原因

```

管理员禁用用户需要提供一个理由，方便查阅；

后端主要设置了一个参数：

```
"Params.status": "disabled"
```

todo: 这里后续需要有一个日志；

应答中

```
"status": "disabled"
```



### 2.3.4 恢复用户

这里与前面的禁用正好相反；

```
"Params.status":"ok"
```

应答中

```
"status": "ok"
```





### 2.3.5 请求登录

如果计算IP后，需要重定向，则返回需要重定向的消息；

如果在登录的地方，先验证时候合法，如果合法，则提示用户应该重定向；

重定向之后使用指纹登录很快；

#### 2.3.5.1 客户端

客户端需要设置登录方式

```
Params["loginmode"] 
"id" , "email", "phone"
```

邮件或者手机，服务端发送验证码后，客户端收到

```
status "waitcode"
```

需要重新提交验证码，如果验证码成功后就会返回登录成功。

```
Status: "loginok"
```



#### 2.3.5.2 服务端

1）如果是密码登录，直接从数据库中加载用户，比对密码；

如果密码一致，则返回

```
Status: "loginok"
```

2）如果是邮件，则会验证邮件格式合法性，以及没有人用过；对邮件发出验证码；



登录成功后，需要一系列的动作，涉及的函数为：

```
onLoginSucces
```



### 2.3.6 提交验证码

需要在

```
params["code"]中设置邮件或者手机收到的验证码
params["action"]中
```

先检查状态，是否设置了需要检查验证码，

之后比对会话中验证码与用户发的是否一致；

如果成功了，根据状态掩码识别当前的状态，分为3种可能：

1）注册阶段

创建用户，保存到mongo中；

```
onRegisterSucces
```

2)  登录阶段

```
onLoginSucces
```

3）更改信息

```go
onChangeInfoSuccess
```



### 2.3.7 设置用户信息

目前阶段设置信息不包括手机信息；

#### 2.3.7.1 客户端

客户端在userOpMsg的params中设置需要更改的字段

1) 要求字段名按照首字母大写的骆驼码方式写

2) 其他Params中的属性名，加前缀，使用小写拼接；类似如下

```
UserName
NickName
Age
Gender
Region
Icon
Email
Phone
Params.pwd
Params.title
```



如果是设置基础信息，一般会成功，并返回

```
"result" = "ok"
"status" = "ok"
```

如果需要更改手机，或者更改邮件，会收到

```
"result" = "ok"
"status" = "waitcode"
```

手机和邮件不能同时更改；



基础信息和需要验证的信息一般不同时操作，如果同时设置，会发送验证码，同时设置基础信息，并返回“waitcode"，

当用户发送正确的验证码后，再设置；

参考2.3.6

### 2.3.8 搜索用户

#### 2.3.8.1 客户端

搜索包括三种：id, name, email,phone 共4种；


UserOpReq中的Params中设置相关字段：


```
Params["mode"] = "id"
Params["value"] = "..."
```

【todo】: 后面可以尝试支持按照地域，按照年龄段，按照当前位置搜索等； 



应答的的数据结构中，如果不是转发的数据，不会填写user字段；而应答的数据都在users中；

#### 2.3.8.2 服务端

这里目前实现了4种查询，后续的根据需求再做；

搜索时候，先查内存（单机版，在线用户），之后查redis（集群，活跃用户）,最后查mongodb，找到后仅仅加载到redis而不加载到内存；

```
findUserMongoRedis
```



### 2.3.9 请求添加好友

#### 2.3.9.1 客户端

请求添加好友必须的精确的；使用UserOpReq的User的表示需要添加对方.需要设置2个字段

```
User.UserId 
User.UserName
User.NickName
```

```
NickName 是可选的，如果设置了，则直接按照此值作为好友昵称，否则使用提供的UserName，这里必须要设置！
```

社区模式：

直接添加好友，收到FriendOpResult中

```
User 用于表示自己，申请者
Users 表示所关注的对方信息；
```

对方好友收到通知：

```
User 粉丝信息，申请者
Users 为空
status = "notify"   // 通知
```

交友模式：





#### 2.3.9.2 服务端

转发时候，需要在User时候附带用户信息；先检测好友是否存在，以及是否被删除等；

1） 在社区模式下不需要检查用户的权限设置；

直接处理，流程如下：onAddFriendOk

1.1) 保存日志；

1.2）双向保存到db;

1.3) 同步到自己的redis, 同步到自己的内存；

1.4) 如果redis中有对方的粉丝缓存，保存到对方的redis中；

1.5） 如果本机有对方的用户内存块，则保存到内存块；

1.6）如果对方在线，则需要通知对方有新粉丝；



2） 在交友模式下需要检查对方的权限，决定是否能添加好友，如果没有被阻挡，onAddFriendStage1

2.1 )检查用户的附加属性，支持几种：

```
Parmas["friendaddmode"]= "direct" | "require" | "reject" | "question"
1）直接通过：Direct Approval
2）需要同意：Approval Required
3）全部拒绝：Reject All
4）回答问题：Answer a Question

如果需要设置回答的问题，设置
Parmas["friendaddanswer"] = "..."
```

- 如果没有设置默认是需要对方同意"require"；


- 如果可以直接添加 "direct"，则直接应答；执行onAddFriendOk

- 如果是"reject"，则说明直接拒绝所有的好友申请，他可能需要加别人；应答中是

```
result = "reject"
```

- 如果是"question" ，则需要检查"question"字段是否设置以及答案是否设置

  检查对方是否正确设置了问题和答案，如果设置了，则应答

```
result = "question"
params["question"]= "..."
```

  

备注：

|          | 用户发给服务                         | 服务转发给用户                              |
| -------- | ------------------------------------ | ------------------------------------------- |
| 好友申请 | User表示要添加的好友                 | User表示申请的用户（需要带上sendId, msgId） |
| 好友应答 | User表示申请人（），好友列表可以为空 | User表示申请人，好友在列表中                |
|          |                                      |                                             |





### 2.3.10 好友确认

#### 2.3.10.1 客户端

收到服务器转发的好友请求的时候，

应答"ok"或者"reject"

同时，可以在params中设置备注

param["memo"]

#### 2.3.10.2 服务端

收到用户的应答之后，

更新记录，同意或者拒绝，之后转发给原始用户；

全程，使用的sendId 和msgId要求一致；



### 2.3.11 移除好友



### 2.3.12 拉黑

### 2.3.13 移除拉黑

### 2.3.14 设置朋友权限

### 2.3.15 设备对方备注

需要区分是为粉丝还是关注设置备注：

```
params["mode"] = "follow" | "fan"
```







